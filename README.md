# Dynamic-indication
Семисегментный индикатор имеет довольно простую конструкцию и состоит из семи сегментов, каждым из которых служит светодиод, расположенный в определенной позиции. Семисегментные индикаторы могут состоять как из одного, так и из нескольких разрядов, чаще всего из двух, трех и четырех.  

Одноразрядный семисегментный индикатор:

![7segment](https://github.com/user-attachments/assets/5b1d1606-c7e1-43f5-b83d-5b4245969c9b) <br>Рис.1

Посмотрим на Рис.1 выше и видим вот эти буквенные обозначения около каждой стороны: 
a - соответствует  нулевому биту
b - первому биту
и т.д. 

Пример:
Хотим получить цифру 7
Значит нам нужно, чтобы загорались положения a, b и c, которым соответствует нулевой, первый и второй бит.
Тогда запись для порта D, к которому подключен нам семисегментный индикатор, будет иметь вид:

PORTD = 0b00000111

![1shema](https://github.com/user-attachments/assets/b6bc2b0b-2da6-490f-a3da-6143b66d7d04) <br>Рис.2

На Рис.2 схема подключения индикатора в Proteus к микроконтроллеру ATmega8. 

*Некоторые нюансы:*
В данной схеме видно, что индикатор соединён с заземлением (ground). Индикатор выбран с общим катодом 7SEG-MPX1-CC.  
**НО** если подключить индикатор с общим анодом, 7SEG-MPX1-CA, то подсоединять надо не к земле, а к power и в таком случае:
если у нас подключение индикатора с общим анодом, то запись нужных нам цифр должна быть инверсной: 

PORTB = 0b11111000; //7 

"нолики" и "единички" поменялись местами.

Пример кода, выполняющий переключение цифр с задержкой в 1 секунду: 
```
#include <avr/io.h>
#include <util/delay.h>
#define F_CPU 1000000UL
#define Time 1000

int main(void)
{
	DDRD = 0b11111111;
	while (1)
	{
		PORTD = 0b00111111; //0
		_delay_ms(Time);
		PORTD = 0b00000110; //1
		_delay_ms(Time);
		PORTD = 0b01011011; //2
		_delay_ms(Time);
		PORTD = 0b01001111; //3
		_delay_ms(Time);
		PORTD = 0b01100110; //4
		_delay_ms(Time);
		PORTD = 0b01101101; //5
		_delay_ms(Time);
		PORTD = 0b01111101; //6
		_delay_ms(Time);
		PORTD = 0b00000111; //7
		_delay_ms(Time);
		PORTD = 0b01111111; //8
		_delay_ms(Time);
		PORTD = 0b01101111; //9
		_delay_ms(Time);
	}
}
```
---

Далее речь пойдёт о 4-х разрядном семисегментном индикаторе.
![4-7s](https://github.com/user-attachments/assets/cdc8c2c0-f325-4a11-8fdc-c1ec64953693) <br>Рис.3

На Рис.3 изображена распиновка для 4-х разрядного семисегментного индикатора. Один разряд - одна цифра на индикаторе. 
У каждого разряда есть свой общий вывод: катод или анод. на фото выше - катод, если диодики смотрели бы вниз, то это был бы общий анод.

![2shema](https://github.com/user-attachments/assets/b139144b-0dfa-477e-b95c-ceae2712b4e1) <br>Рис.4

На Рис.4 изображена схема подключение индикатора в Proteus к микроконтроллеру ATmega8. 

Допустим, что стоит задача просто вывести число, например, 1307:

```
#include <avr/io.h> 
#include <util/delay.h>  // библиотека задержек
#define F_CPU 1000000UL  // определяем тактовую частоту микроконтроллера (зависит от выбранного микроконтроллера)
#define T 3

int chisla [10] = {
	0b00111111, //0
	0b00000110, //1
	0b01011011, //2
	0b01001111, //3
	0b01100110, //4
	0b01101101, //5
	0b01111101, //6
	0b00000111, //7
	0b01111111, //8
	0b01101111, //9
};

int main(void)
{
	DDRD = 0b11111111; // PORDD - отвечает за то, что написано в одном разряде
	PORTD = 0b00000110; // с подачей напряжения будет загораться цифра 1
	
	DDRB = 0b00001111; // PORDB - отвечает за разряд (1, 2, 3 или 4)
	PORTB = 0b00000001; // при подаче напряжения сразу будет гореть первый разряд индикатора
		
	while (1)
	{
		PORTB = 0b00000001; PORTD = chisla[1]; // на первом разряде вывод цифры 1
		_delay_ms(T);
		PORTB = 0b00000010; PORTD = chisla[3]; // на втором разряде вывод цифры 3
		_delay_ms(T);
		PORTB = 0b00000100; PORTD = chisla[0]; // на третьем разряде вывод цифры 0
		_delay_ms(T);
		PORTB = 0b00001000; PORTD = chisla[7]; // на чётвертом разряде вывод цифры 7
		_delay_ms(T);
	}
}
```
Все цифры не светятся одновременно, а переключаются по очереди с задержкой T. Так как эта задержка всего 3 милисекунды, мы не замечаем как быстро происходит переключение. 

DDRx - direct data registor (регистры направления данных)

DDRx = 0 - вход
DDRx = 1 - выход

PORTx - настройка регистра потенциала

PORTx = 0 - 0В
PORTx = 1 - 5В 

---

Если стоит задачка: на индикаторе 0000. при нажатии на одну кнопку можно увеличивать число и при нажатии на другую кнопку это число можно уменьшать.

![3shema](https://github.com/user-attachments/assets/8d9b1ddd-50fc-4d34-9573-a27a60c9a69a) <br>Рис.5

Подключили кнопки к выводам порта С (Рис.5)
В данном случае будет необходимо использовать таймер-счётчик. 

```
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#define F_CPU 1000000UL
#define T 300

unsigned char z = 1;
unsigned int ind = 0;

unsigned int chisla [10] = {
	0b00111111, //0
	0b00000110, //1
	0b01011011, //2
	0b01001111, //3
	0b01100110, //4
	0b01101101, //5
	0b01111101, //6
	0b00000111, //7
	0b01111111, //8
	0b01101111, //9
};

unsigned int razr1 = 0, razr2 = 0, razr3 = 0, razr4 = 0;

void vse_na_indikatore (unsigned int razbivka_chisla) {
	razr1 = razbivka_chisla/1000; 
	// переменная для первого разряда индикатора
	razr2 = razbivka_chisla%1000/100; 
	// переменная для второго разряда индикатора
	razr3 = razbivka_chisla%100/10; 
	// переменная для третьего разряда индикатора
	razr4 = razbivka_chisla%10; 
	// переменная для четвертого разряда индикатора
}

ISR (TIMER0_OVF_vect) {
	if (z == 1) {PORTB = 0b00000001; PORTD = chisla[razr1];}
	if (z == 2) {PORTB = 0b00000010; PORTD = chisla[razr2];}
	if (z == 3) {PORTB = 0b00000100; PORTD = chisla[razr3];}
	if (z == 4) {PORTB = 0b00001000; PORTD = chisla[razr4];}
	z++;
	
	if (z > 4) {z=1;}
};

int main(void)
{
	DDRD = 0b11111111;  
	// PORDD - отвечает за то, что написано в одном разряде
	PORTD = 0b00000000;

	DDRB = 0b00001111; // PORDB - отвечает за разряд
	PORTB = 0b00000000; 
	// при подаче напряжения не будут сразу гореть индикаторы
	
	DDRC &= ~((1<<4) | (1<<5));
	// настроим 4 и 5 выход порта С на вход (нолики), 
	чтобы подключить туда кнопочки
	PORTC |= ((1<<4) | (1<<5)); 
	// установили подтягивающие резисторы (единички) на 4 и 5 выходы порта С
	
	TCCR0 |= (1<<2); TCCR0 &= ~((1<<0) | (1<<1)); 
	//  Настройка таймера с предделителем на f/256
	TCNT0 = 0; // обнуление таймер-счётчика 
	TIMSK |= (1<<0); // Разрешить прерывание по переполнению таймера
	sei(); // разрешить глобальные прерывания
	
	while (1)
	{
		vse_na_indikatore(ind); 
		// изначально на индикаторе будут все нули 0000
		
		if (~PINC & (1<<5)) { 
		// при нажатии на кнопку, подключенную к порту PC5, 
			ind++;            
		// число на индикаторе будет увеличиваться
			_delay_ms(T);
		}
		if (~PINC & (1<<4)) { 
		// при нажатии на кнопку, подключенную к порту PC4,
			ind--;            
		// число на индикаторе будет уменьшаться
			_delay_ms(T);
		}
	}
}
```
---
Численный и буквенный массивы:

```
int chisla [10] = {
	0b00111111, //0
	0b00000110, //1
	0b01011011, //2
	0b01001111, //3
	0b01100110, //4
	0b01101101, //5
	0b01111101, //6
	0b00000111, //7
	0b01111111, //8
	0b01101111, //9
};

int bukva [12] = {
	0b00110111, // Буква П 0
	0b01101110, // Буква У 1
	0b00111001, // Буква С 2
	0b01111001, // Буква E 3
	0b01111101, // Буква Б 4
	0b00110001, // Буква Г 5
	0b01001111, // Буква З 6
	0b01110110, // Буква Н 7
	0b00111111, // Буква О 8
	0b01110011, // Буква Р 9
	0b01100110, // Буква Ч 10
	0b01111100  // Буква Ь 11
};
```
